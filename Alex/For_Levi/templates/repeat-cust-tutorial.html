<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Lazuli - Leverage Your Data</title>
    <link rel="stylesheet" href="main.css">
      <!-- CSS only -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
    <!-- JS, Popper.js, and jQuery -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@700&family=Open+Sans+Condensed:ital,wght@1,300&display=swap" rel="stylesheet">
    <style>
       .codebox {
        /* Below are styles for the codebox (not the code itself) */
        border:1px black;
        background-color: #EAEBEC;
        width:1000px;
        overflow:auto;    
        padding-top:15px;
        padding-bottom: 1px; 
    }
    .codebox code {
        /* Styles in here affect the text of the codebox */
        font-size:0.9em;
        font-family: Courier New Lucida Console;
        color: black;
        /* You could also put all sorts of styling here, like different font, color, underline, etc. for the code. */
    }
    .title {
      padding-top: 30px;
      padding-right: 30px;
      padding-bottom: 30px;
      padding-left: 80px;
    }
    .container {
      padding-top: 30px;
      padding-right: 30px;
      padding-bottom: 30px;
      padding-left: 80px;
    }
    </style>
</head>
<body>
<!-- Nav Bar -->
<nav class="navbar navbar-md navbar-dark bg-dark">
  <img src="images/Lazuli.png" width="150" height="60">
    <ul class="nav navbar-right">
        <li class="nav-item">
            <a class="nav-link active" href="landing-page.html">Home</a>
          </li>
        <li class="nav-item">
          <a class="nav-link active" href="about.html">About</a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Features</a>
          <div class="dropdown-menu">
            <a class="dropdown-item" href="main.html">Model 1</a>
            <a class="dropdown-item" href="#">Model 2</a>
            <a class="dropdown-item" href="#">Model 3</a>
          </div>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="#">Support</a>
        </li>
      </ul>
</nav>
<!-- start title -->
<div class="title">
    <div class="row justify-content-md-center">
        <div class ="col col-lg-auto">
            <h1><b>Predict Repeat Customers Using Logsitic Regression</b></h1>
        </div>
    </div>
</div>
<!-- end title -->
<!-- start banner div -->
<div class="container">
  <div class="row justify-content-md-center">
    <div class ="col col-lg-auto"></div>
        <img src="images/repeat-cust.jpeg" class="img-fluid" alt="machine learning">
    </div>
  </div>
</div>
<!-- end banner div-->
<!-- start content-->
<!-- part 1 div container-->
<div class="container">
  
    <h2>Part 1: Pre-processing the Data</h2>
      <p>Before begining to train models we should transform our data in a way that can be fed into a Machine Learning model. 
        Our most used techniques are:
      </p>
  
      <h4>1.1 Dropping Rows With Null Values</h4>
      <p>[In]:</p>
    <!-- codebox div-->
      <div class="codebox">
        <pre>
          <code>
            file_cust = file_cust.dropna()
            file_geo = file_geo.dropna()
            file_items = file_items.dropna()
            file_payments = file_payments.dropna()
            file_reviews = file_reviews.dropna()
            file_orders = file_orders.dropna()
            file_products = file_products.dropna()
            file_sellers = file_sellers.dropna()
            file_category = file_category.dropna()
            </code>
        </pre>
      </div>
      <br>
      <h4>1.2 Merging Dataframes</h4>
      <p>[In]:</p>
      <div class="codebox">
        <pre>
          <code>
            data = file_orders.merge(file_items, on='order_id',how='left')
            data = data.merge(file_payments, on='order_id',how='outer',validate='m:m')
            data = data.merge(file_reviews, on='order_id',how='outer')
            data = data.merge(file_products,on='product_id',how='outer')
            data = data.merge(file_cust,on='customer_id',how='outer')
            data = data.merge(file_sellers, on='seller_id',how='outer')
            data = data.merge(file_category, on='product_category_name',how='outer')
            </code>
        </pre>
      </div>
        <br>
      <h4>1.3 Convert Data Type</h4>
          <p>
            In order to work with a data that would be condusive to our desired outcome, we convert all
            columns that include date and time information into datetime format using pd.to_datetime on 
            those columns.
          </p>
          <br>
      <h4>1.4 Defining Repeat Customers in the Data</h4>
            <p>
              In order to reduce the data into two dataframes, one identifying repeat customers and the 
              other identifying non-repeat customers, we need to create a new dataframe with each unique
              customer and their total number of purchases. Then we extract the unique customer id's of the
              customers who made more than one purchase and store them in an array. The last step is to 
              create a new column with our working dataframe that identifies repeat and non-repeat customers
              by assigning a "0" for customers not in the repeat array and a "1" to customers in the repeat 
              array. We will use this new column as the dependent variable, or "y" variable, to insert into 
              the model. 
            </p>
            <p>[In]:</p>
          <div class="codebox">
            <pre>
              <code>
                df = unique_orders['customer_unique_id'].value_counts().rename_axis('unique_values').reset_index(name='counts')

                df1 = df.loc[df['counts'] > 1]

                repeat_list = df1['unique_values'].tolist()

                data["repeat?"] = np.where(data["customer_unique_id"].isin(repeat_list), 1, 0)
                
              </code>
            </pre>
          </div>
          <br>
      <h4>1.5 Selecting Meaningful Features</h4>
            <p>
              One of the main reasons that causes machine learning models to overfit is because of having redundancy in our data, 
              which makes the model to be too complex for the given training data and unable to generalize well on unseen data.
              We decide to reduce data’s dimensionality, helping the model to learn its weights apropriately. 
            </p>
            <p>[In]:</p>
          <div class="codebox">
            <pre>
              <code>
                target = df_train["Positive_or_Negative"]
                target_names = ["negative", "positive"]
              </code>
            </pre>
          </div>
            
        
      
    <!-- end part 1 div container-->
    <!-- part 2 div container-->
    <br>
      <h3>Part 2: Prediction Model</h3>
        <h4>2.1 Selecting Meaningful Features</h4>
          <p>
            We trained a RandomForestClassifier on the dataset to predict customer satisfaction which requires 5 features — 
            <li>
              Total_Order_Value
            </li>
            <li>
              Product_description_lenght
            </li>
            <li>
              Is_It_Late?
            </li>
            <li>
              Product_photos_qty
            </li>
            <li>Payment_Type</li> 
          </p>
          <br>
        <h4>2.2 Training the Model & Prediction Model Result</h4>
          <p>
            The model was trained using RandomForestClassifier
          </p>
          <p>[In]:</p>
        <div class="codebox">
          <pre>
            <code>
              X_train, X_test, y_train, y_test = train_test_split(data, target, random_state=42)
              rf2 = RandomForestClassifier(n_estimators=200)
              rf2 = rf2.fit(X_train, y_train)
              rf2.score(X_test, y_test)
              sorted(zip(rf2.feature_importances_, feature_names), reverse=True)
            </code>
          </pre>
        </div>
        
    <!-- End part 2 div container-->
    <!-- part 3 div container-->
    <br>
      <h3>Part 3: Connect Model to Web App</h3>
        <h4>3.1 Save the Model</h4>
          <p>
            Using pickle module in pandas, export model into a file to later connect with Flask app
          </p>
          <p>[In]:</p>
        <div class="codebox">
          <pre>
            <code>
              <b>import</b> pickle
              with open('customer_satisfaction.pkl', 'wb') as file:
              pickle.dump(rf2, file)
            </code>
          </pre>
        </div>
        <br>
      <h4>3.2 Flask App Connect</h4>
      <p>
        Create app.py to load the model
      </p>
      <div class="codebox">
        <pre>
          <code>
            import flask
            import pickle
            import pandas as pd

            <i># Use pickle to load in the pre-trained model</i>
            with open(f'customer_satisfaction.pkl', 'rb') as f:
            model = pickle.load(f)

            <i># Initialise the Flask app</i>
            app = flask.Flask(__name__, template_folder='templates')

            <i># Set up the main route</i>
            @app.route('/', methods=['GET', 'POST'])
            def main():
              if flask.request.method == 'GET':
              # Just render the initial form, to get input
              return(flask.render_template('main.html'))
              if flask.request.method == 'POST':

            <i># Extract the input</i>
              product_description_lenght = flask.request.form['product_description_lenght']
              product_photos_qty = flask.request.form['product_photos_qty']
              Is_It_Late = flask.request.form['Is_It_Late']
              Payment_Type = flask.request.form['Payment_Type']
              Total_Order_Value = flask.request.form['Total_Order_Value']

            <i># Make DataFrame for model</i>
              input_variables = pd.DataFrame([[product_description_lenght, product_photos_qty, Is_It_Late, Payment_Type,Total_Order_Value]],
                                              columns=['product_description_lenght', 'product_photos_qty', 'Is_It_Late',
                                              'Payment_Type', 'Total_Order_Value'],
                                              dtype=float,
                                              index=['input'])

            <i># Get the model's prediction</i>
              prediction = model.predict(input_variables)[0]
                  
            <i># Render the form again, but add in the prediction and remind user of the values they input before</i>
                return flask.render_template('main.html',
                original_input={'product_description_lenght':product_description_lenght,
                                'product_photos_qty':product_photos_qty,
                                'Is_It_Late':Is_It_Late,
                                'Payment_Type':Payment_Type,
                                'Total_Order_Value':Total_Order_Value},
                                result=prediction,)
              if __name__ == '__main__':
                  app.run(debug=True)
          </code>
        </pre>
      </div>
    <!-- End part 3 div container-->
      </div>
</div>

</body>

</html>
